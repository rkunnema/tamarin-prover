theory Chen_Kudla begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman, bilinear-pairing
functions: fst/1, h/1, hp/1, kdf/1, pair/2, snd/1
equations: fst(<x.1, x.2>) = x.1, snd(<x.1, x.2>) = x.2







section{* A variant of the Chen-Kudla protocol that uses ordered concatenation instead 
          addition of points *}

rule (modulo E) KGC_Setup:
   [ Fr( ~msk ) ]
  --[ KGCSetup( ) ]->
   [ !MSK( ~msk ), !MPK( pmult(~msk, 'P') ), Out( pmult(~msk, 'P') ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) KGC_request:
   [ !MSK( ~msk ) ] --> [ !LTK( $ID, pmult(~msk, hp($ID)) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ltk:
   [ !LTK( $ID, skID ) ] --[ LtkRev( $ID ) ]-> [ Out( skID ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_master_key:
   [ !MSK( ~msk ) ] --[ MskRev( ) ]-> [ Out( ~msk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_session_key:
   [ !Sessk( ~ey, kdf(sek) ) ] --[ SesskRev( ~ey ) ]-> [ Out( kdf(sek) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Reveal_ephemeral_key:
   [ !Ephk( ~ex ) ] --[ EphkRev( ~ex ) ]-> [ Out( ~ex ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_1:
   [ Fr( ~ex ) ]
  -->
   [ Init( ~ex, $A, $B ), Out( pmult(~ex, 'P') ), !Ephk( ~ex ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init_2:
   [
   Init( ~ex, $A, $B ), !MPK( pmult(~s2, 'P') ),
   !LTK( $A, pmult(~s1, hp($A)) ), In( Y )
   ]
  --[
  Accept( ~ex, $A, $B,
          kdf(<em(hp($B), pmult(~s2, 'P'))^~ex, em(Y, pmult(~s1, hp($A))), 
               pmult(~ex, Y), $A, $B, pmult(~ex, 'P'), Y>)
  ),
  Sid( ~ex, <'Init', $A, $B, pmult(~ex, 'P'), Y> ),
  Match( ~ex, <'Resp', $B, $A, pmult(~ex, 'P'), Y> )
  ]->
   [
   !Sessk( ~ex,
           kdf(<em(hp($B), pmult(~s2, 'P'))^~ex, em(Y, pmult(~s1, hp($A))), 
                pmult(~ex, Y), $A, $B, pmult(~ex, 'P'), Y>)
   )
   ]

  /*
  rule (modulo AC) Init_2:
     [
     Init( ~ex, $A, $B ), !MPK( pmult(~x.1, 'P') ),
     !LTK( $A, pmult(~x, hp($A)) ), In( Y )
     ]
    --[
    Accept( ~ex, $A, $B,
            kdf(<em('P', hp($B))^(~ex*~x.1), z, z.1, $A, $B, pmult(~ex, 'P'), Y>)
    ),
    Sid( ~ex, <'Init', $A, $B, pmult(~ex, 'P'), Y> ),
    Match( ~ex, <'Resp', $B, $A, pmult(~ex, 'P'), Y> )
    ]->
     [
     !Sessk( ~ex,
             kdf(<em('P', hp($B))^(~ex*~x.1), z, z.1, $A, $B, pmult(~ex, 'P'), Y>)
     )
     ]
    variants (modulo AC)
     1. $A    = $A.52
        ~ex   = ~ex.54
        ~x    = ~ex.54
        Y     = pmult(inv(~ex.54), z.62)
        z     = em(z.62, hp($A.52))
        z.1   = z.62
    
     2. $A    = $A.55
        ~ex   = ~ex.57
        ~x    = ~x.74
        Y     = Y.60
        z     = em(Y.60, hp($A.55))^~x.74
        z.1   = pmult(~ex.57, Y.60)
    
     3. $A    = $A.55
        ~ex   = ~ex.57
        ~x    = ~x.74
        Y     = pmult(inv(~ex.57), z.65)
        z     = em(z.65, hp($A.55))^(~x.74*inv(~ex.57))
        z.1   = z.65
    
     4. $A    = $A.619
        ~ex   = ~ex.621
        ~x    = ~x.638
        Y     = pmult(x.1235, x.1236)
        z     = em(x.1236, hp($A.619))^(~x.638*x.1235)
        z.1   = pmult((~ex.621*x.1235), x.1236)
    
     5. $A    = $A.620
        ~ex   = ~ex.622
        ~x    = ~x.639
        Y     = pmult(inv(~x.639), x.1238)
        z     = em(x.1238, hp($A.620))
        z.1   = pmult((~ex.622*inv(~x.639)), x.1238)
    
     6. $A    = $A.621
        ~ex   = ~ex.623
        ~x    = ~x.640
        Y     = pmult(inv((~ex.623*~x.640)), x.1240)
        z     = em(x.1240, hp($A.621))^inv(~ex.623)
        z.1   = pmult(inv(~x.640), x.1240)
    
     7. $A    = $A.621
        ~ex   = ~ex.623
        ~x    = ~ex.623
        Y     = pmult(inv((~ex.623*x.1239)), x.1240)
        z     = em(x.1240, hp($A.621))^inv(x.1239)
        z.1   = pmult(inv(x.1239), x.1240)
    
     8. $A    = $A.621
        ~ex   = ~ex.623
        ~x    = ~x.640
        Y     = pmult(inv((~x.640*x.1239)), x.1240)
        z     = em(x.1240, hp($A.621))^inv(x.1239)
        z.1   = pmult((~ex.623*inv((~x.640*x.1239))), x.1240)
    
     9. $A    = $A.621
        ~ex   = ~ex.623
        ~x    = ~ex.623
        Y     = pmult((x.1239*inv(~ex.623)), x.1240)
        z     = em(x.1240, hp($A.621))^x.1239
        z.1   = pmult(x.1239, x.1240)
    
    10. $A    = $A.621
        ~ex   = ~ex.623
        ~x    = ~x.640
        Y     = pmult((x.1239*inv(~x.640)), x.1240)
        z     = em(x.1240, hp($A.621))^x.1239
        z.1   = pmult((~ex.623*x.1239*inv(~x.640)), x.1240)
    
    11. $A    = $A.622
        ~ex   = ~ex.624
        ~x    = ~x.641
        Y     = pmult(inv((~ex.624*~x.641*x.1241)), x.1242)
        z     = em(x.1242, hp($A.622))^inv((~ex.624*x.1241))
        z.1   = pmult(inv((~x.641*x.1241)), x.1242)
    
    12. $A    = $A.622
        ~ex   = ~ex.624
        ~x    = ~x.641
        Y     = pmult(inv((~ex.624*x.1241)), x.1242)
        z     = em(x.1242, hp($A.622))^(~x.641*inv((~ex.624*x.1241)))
        z.1   = pmult(inv(x.1241), x.1242)
    
    13. $A    = $A.622
        ~ex   = ~ex.624
        ~x    = ~ex.624
        Y     = pmult((x.1240*inv((~ex.624*x.1241))), x.1242)
        z     = em(x.1242, hp($A.622))^(x.1240*inv(x.1241))
        z.1   = pmult((x.1240*inv(x.1241)), x.1242)
    
    14. $A    = $A.622
        ~ex   = ~ex.624
        ~x    = ~x.641
        Y     = pmult((x.1240*inv((~x.641*x.1241))), x.1242)
        z     = em(x.1242, hp($A.622))^(x.1240*inv(x.1241))
        z.1   = pmult((~ex.624*x.1240*inv((~x.641*x.1241))), x.1242)
    
    15. $A    = $A.622
        ~ex   = ~ex.624
        ~x    = ~x.641
        Y     = pmult((x.1241*inv(~ex.624)), x.1242)
        z     = em(x.1242, hp($A.622))^(~x.641*x.1241*inv(~ex.624))
        z.1   = pmult(x.1241, x.1242)
    
    16. $A    = $A.622
        ~ex   = ~ex.624
        ~x    = ~x.641
        Y     = pmult((x.1241*inv((~ex.624*~x.641))), x.1242)
        z     = em(x.1242, hp($A.622))^(x.1241*inv(~ex.624))
        z.1   = pmult((x.1241*inv(~x.641)), x.1242)
    
    17. $A    = $A.623
        ~ex   = ~ex.625
        ~x    = ~x.642
        Y     = pmult((x.1242*inv((~ex.625*~x.642*x.1243))), x.1244)
        z     = em(x.1244, hp($A.623))^(x.1242*inv((~ex.625*x.1243)))
        z.1   = pmult((x.1242*inv((~x.642*x.1243))), x.1244)
    
    18. $A    = $A.623
        ~ex   = ~ex.625
        ~x    = ~x.642
        Y     = pmult((x.1242*inv((~ex.625*x.1243))), x.1244)
        z     = em(x.1244, hp($A.623))^(~x.642*x.1242*inv((~ex.625*x.1243)))
        z.1   = pmult((x.1242*inv(x.1243)), x.1244)
  */

rule (modulo E) Resp_1:
   [
   Fr( ~ey ), !LTK( $B, pmult(~msk, hp($B)) ), !MPK( pmult(~msk, 'P') ),
   In( X )
   ]
  --[
  Accept( ~ey, $B, $A,
          kdf(<em(X, pmult(~msk, hp($B))), em(hp($A), pmult(~msk, 'P'))^~ey, 
               pmult(~ey, X), $A, $B, X, pmult(~ey, 'P')>)
  ),
  Sid( ~ey, <'Resp', $B, $A, X, pmult(~ey, 'P')> ),
  Match( ~ey, <'Init', $A, $B, X, pmult(~ey, 'P')> )
  ]->
   [
   Out( pmult(~ey, 'P') ),
   !Sessk( ~ey,
           kdf(<em(X, pmult(~msk, hp($B))), em(hp($A), pmult(~msk, 'P'))^~ey, 
                pmult(~ey, X), $A, $B, X, pmult(~ey, 'P')>)
   ),
   !Ephk( ~ey )
   ]

  /*
  rule (modulo AC) Resp_1:
     [
     Fr( ~ey ), !LTK( $B, pmult(~x, hp($B)) ), !MPK( pmult(~x, 'P') ), In( X )
     ]
    --[
    Accept( ~ey, $B, $A,
            kdf(<z, em('P', hp($A))^(~ey*~x), pmult(x.1, x.2), $A, $B, X, 
                 pmult(~ey, 'P')>)
    ),
    Sid( ~ey, <'Resp', $B, $A, X, pmult(~ey, 'P')> ),
    Match( ~ey, <'Init', $A, $B, X, pmult(~ey, 'P')> )
    ]->
     [
     Out( pmult(~ey, 'P') ),
     !Sessk( ~ey,
             kdf(<z, em('P', hp($A))^(~ey*~x), pmult(x.1, x.2), $A, $B, X, 
                  pmult(~ey, 'P')>)
     ),
     !Ephk( ~ey )
     ]
    variants (modulo AC)
    1. $B    = $B.51
       ~ey   = ~ey.52
       ~x    = ~x.65
       X     = X.54
       z     = em(X.54, hp($B.51))^~x.65
       x.1   = ~ey.52
       x.2   = X.54
    
    2. $B    = $B.61
       ~ey   = ~ey.62
       ~x    = ~x.75
       X     = pmult(inv(~x.75), x.85)
       z     = em(x.85, hp($B.61))
       x.1   = (~ey.62*inv(~x.75))
       x.2   = x.85
    
    3. $B    = $B.661
       ~ey   = ~ey.662
       ~x    = ~x.675
       X     = pmult(x.1319, x.685)
       z     = em(x.685, hp($B.661))^(~x.675*x.1319)
       x.1   = (~ey.662*x.1319)
       x.2   = x.685
    
    4. $B    = $B.662
       ~ey   = ~ey.663
       ~x    = ~x.676
       X     = pmult(inv((~x.676*x.1321)), x.686)
       z     = em(x.686, hp($B.662))^inv(x.1321)
       x.1   = (~ey.663*inv((~x.676*x.1321)))
       x.2   = x.686
    
    5. $B    = $B.662
       ~ey   = ~ey.663
       ~x    = ~x.676
       X     = pmult((x.1321*inv(~x.676)), x.686)
       z     = em(x.686, hp($B.662))^x.1321
       x.1   = (~ey.663*x.1321*inv(~x.676))
       x.2   = x.686
    
    6. $B    = $B.663
       ~ey   = ~ey.664
       ~x    = ~x.677
       X     = pmult((x.1322*inv((~x.677*x.1323))), x.687)
       z     = em(x.687, hp($B.663))^(x.1322*inv(x.1323))
       x.1   = (~ey.664*x.1322*inv((~x.677*x.1323)))
       x.2   = x.687
  */

lemma key_secrecy_eCK_like:
  all-traces
  "∀ #i1 #i2 test A B k.
    ((Accept( test, A, B, k ) @ #i1) ∧ (K( k ) @ #i2)) ⇒
    ((((∃ #i3. SesskRev( test ) @ #i3) ∨
       (∃ #i3 #i4.
         ((KGCSetup( ) @ #i3) ∧ (KGCSetup( ) @ #i4)) ∧ (¬(#i3 = #i4)))) ∨
      (∃ matching #i3 #i4 sid.
        ((Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4)) ∧
        (((∃ #i5. SesskRev( matching ) @ #i5) ∨
          (((∃ #i5. LtkRev( B ) @ #i5) ∨ (∃ #i5. MskRev( ) @ #i5)) ∧
           (∃ #i5. EphkRev( matching ) @ #i5))) ∨
         (((∃ #i5. LtkRev( A ) @ #i5) ∨ (∃ #i5. MskRev( ) @ #i5)) ∧
          (∃ #i5. EphkRev( test ) @ #i5))))) ∨
     ((¬(∃ matching #i3 #i4 sid.
          (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4))) ∧
      (((∃ #i5. LtkRev( B ) @ #i5) ∨ (∃ #i3. EphkRev( test ) @ #i3)) ∨
       (∃ #i3. MskRev( ) @ #i3))))"
/*
guarded formula characterizing all counter-examples:
"∃ #i1 #i2 test A B k.
  (Accept( test, A, B, k ) @ #i1) ∧ (K( k ) @ #i2)
 ∧
  (∀ #i3. (SesskRev( test ) @ #i3) ⇒ ⊥) ∧
  (∀ #i3 #i4. (KGCSetup( ) @ #i3) ∧ (KGCSetup( ) @ #i4) ⇒ #i3 = #i4) ∧
  (∀ matching #i3 #i4 sid.
    (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4)
   ⇒
    (∀ #i5. (SesskRev( matching ) @ #i5) ⇒ ⊥) ∧
    ((((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧ (∀ #i5. (MskRev( ) @ #i5) ⇒ ⊥)) ∨
      (∀ #i5. (EphkRev( matching ) @ #i5) ⇒ ⊥))) ∧
    ((((∀ #i5. (LtkRev( A ) @ #i5) ⇒ ⊥) ∧ (∀ #i5. (MskRev( ) @ #i5) ⇒ ⊥)) ∨
      (∀ #i5. (EphkRev( test ) @ #i5) ⇒ ⊥)))) ∧
  (((∃ matching #i3 #i4 sid.
      (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4)) ∨
    ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧
     (∀ #i3. (EphkRev( test ) @ #i3) ⇒ ⊥) ∧
     (∀ #i3. (MskRev( ) @ #i3) ⇒ ⊥))))"
*/
simplify
solve( (∃ matching #i3 #i4 sid.
         (Sid( matching, sid ) @ #i3) ∧ (Match( test, sid ) @ #i4))  ∥
       ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧
        (∀ #i3. (EphkRev( test ) @ #i3) ⇒ ⊥) ∧
        (∀ #i3. (MskRev( ) @ #i3) ⇒ ⊥)) )
  case case_1
  solve( ((∀ #i5. (LtkRev( B ) @ #i5) ⇒ ⊥) ∧
          (∀ #i5. (MskRev( ) @ #i5) ⇒ ⊥))  ∥
         (∀ #i5. (EphkRev( matching ) @ #i5) ⇒ ⊥) )
    case case_1
    solve( ((∀ #i5. (LtkRev( A ) @ #i5) ⇒ ⊥) ∧
            (∀ #i5. (MskRev( ) @ #i5) ⇒ ⊥))  ∥
           (∀ #i5. (EphkRev( test ) @ #i5) ⇒ ⊥) )
      case case_1
      solve( Accept( test, A, B, k ) @ #i1 )
        case Init_2
        solve( Init( ~ex, $A, $B ) ▶₀ #i1 )
          case Init_1
          solve( !MPK( pmult(~x, 'P') ) ▶₁ #i1 )
            case KGC_Setup
            solve( !LTK( $A, pmult(~x.1, hp($A)) ) ▶₂ #i1 )
              case KGC_request
              solve( Sid( matching, sid ) @ #i3 )
                case Resp_1
                solve( !LTK( $B.1, pmult(~x.1, hp($B.1)) ) ▶₁ #i3 )
                  case KGC_request
                  solve( !MPK( pmult(~x, 'P') ) ▶₂ #i3 )
                    case KGC_Setup
                    solve( Match( ~ex, <'Resp', $B.1, $A.1, X, pmult(~ey, 'P')> ) @ #i4 )
                      case Init_2
                      solve( Init( ~ex, $A.1, $B.1 ) ▶₀ #i4 )
                        case Init_1
                        solve( !KU( kdf(<em('P', hp($B))^(~ex*~x), em('P', hp($A))^(~ey*~x), 
                                         pmult((~ex*~ey), 'P'), $A, $B, pmult(~ex, 'P'), pmult(~ey, 'P')>)
                               ) @ #vk )
                          case c_kdf
                          solve( !KU( em('P', hp($B))^(~ex*~x) ) @ #vk.5 )
                            case KGC_Setup
                            solve( !KU( ~ex ) @ #vk.15 )
                              case Reveal_ephemeral_key
                              solve( !KU( em('P', hp($A))^(~ey*~x) ) @ #vk.10 )
                                case KGC_Setup
                                solve( !KU( ~ey ) @ #vk.17 )
                                  case Reveal_ephemeral_key
                                  solve( !KU( pmult((~ex*~ey), 'P') ) @ #vk.13 )
                                    case Init_1
                                    solve( !KU( hp($B) ) @ #vk.16 )
                                      case c_hp
                                      solve( !KU( hp($A) ) @ #vk.17 )
                                        case c_hp
                                        solve( !KU( pmult(~ex, 'P') ) @ #vk.10 )
                                          case Init_1
                                          solve( !KU( pmult(~ey, 'P') ) @ #vk.14 )
                                            case Resp_1
                                            SOLVED // trace found
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed













/*
WARNING: the following wellformedness checks failed!

Message Derivation Checks
=========================

  The variables of the following rule(s) are not derivable from their premises, you may be performing unintended pattern matching.

Rule Reveal_session_key: 
Failed to derive Variable(s): sek

Rule Init_2: 
Failed to derive Variable(s): ~s1, ~s2

Rule Resp_1: 
Failed to derive Variable(s): ~msk
*/

/*
Generated from:
Tamarin version 1.11.0
Maude version 3.4
Git revision: d224b4b965f014cbf18a3a01c5afbd5b20576914 (with uncommited changes), branch: develop
Compiled at: 2025-09-08 09:04:28.158015016 UTC
*/

end
/* Output

==============================================================================
summary of summaries:

analyzed: examples/ake/bilinear/Chen_Kudla_eCK.spthy

  output:          examples/ake/bilinear/Chen_Kudla_eCK.spthy.tmp
  processing time: 24.77s
  
  WARNING: 1 wellformedness check failed!
           The analysis results might be wrong!
  
  key_secrecy_eCK_like (all-traces): falsified - found trace (24 steps)

==============================================================================
*/
